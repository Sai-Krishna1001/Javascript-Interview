# Data Structures and Algorithms Terminology Keywords Dictionary

## Data Structures

| **Keyword/Term**           | **Definition**                                                                                       |
|----------------------------|------------------------------------------------------------------------------------------------------|
| **Array**                  | A collection of elements, each identified by an index or key. Arrays are typically used to store sequences of elements of the same type. |
| **Linked List**            | A linear data structure where each element, called a node, contains a value and a reference (or link) to the next node in the sequence. |
| **Stack**                  | A linear data structure that follows the Last-In-First-Out (LIFO) principle. Elements are added and removed from the top of the stack. |
| **Queue**                  | A linear data structure that follows the First-In-First-Out (FIFO) principle. Elements are added at the rear and removed from the front. |
| **Hash Table**             | A data structure that maps keys to values using a hash function. Hash tables allow for fast data retrieval based on key values. |
| **Binary Tree**            | A hierarchical data structure in which each node has at most two children, referred to as the left child and the right child. |
| **Binary Search Tree (BST)**| A type of binary tree where each node's left child contains values less than the node, and the right child contains values greater than the node. |
| **Heap**                   | A specialized tree-based data structure that satisfies the heap property, where the parent node is either greater than or equal to (max-heap) or less than or equal to (min-heap) its children. |
| **Graph**                  | A collection of nodes (vertices) and edges connecting pairs of nodes. Graphs can be directed or undirected, and may contain cycles. |
| **Trie**                   | A tree-like data structure used for storing strings in a way that allows for efficient retrieval, especially in scenarios involving prefix searches. |
| **Set**                    | A collection of unique elements that supports operations like union, intersection, and difference. Sets are commonly used for membership tests. |
| **Dictionary (Map)**       | A collection of key-value pairs, where each key is unique. Dictionaries allow for fast lookups, additions, and deletions based on keys. |
| **Deque (Double-ended Queue)** | A linear data structure that allows elements to be added or removed from both the front and the rear. Deques support both LIFO and FIFO operations. |

## Algorithms

| **Keyword/Term**           | **Definition**                                                                                       |
|----------------------------|------------------------------------------------------------------------------------------------------|
| **Sorting Algorithm**      | An algorithm that arranges the elements of a list or array in a specific order, typically ascending or descending. Common examples include Quick Sort, Merge Sort, and Bubble Sort. |
| **Search Algorithm**       | An algorithm that retrieves information stored within a data structure. Common examples include Binary Search and Linear Search. |
| **Dynamic Programming**    | A method for solving complex problems by breaking them down into simpler subproblems and solving each subproblem only once, storing the solutions for future use. |
| **Greedy Algorithm**       | An algorithmic paradigm that builds up a solution piece by piece, always choosing the next piece that offers the most immediate benefit. |
| **Divide and Conquer**     | An algorithm design paradigm based on recursively breaking down a problem into two or more subproblems until they become simple enough to solve directly. |
| **Backtracking**           | A recursive algorithmic technique that explores all possible solutions for a problem by trying one possibility at a time and undoing it (backtracking) if it does not lead to a solution. |
| **Recursion**              | The process of solving a problem where a function calls itself as a subroutine. Recursion is often used in divide-and-conquer algorithms. |
| **Breadth-First Search (BFS)** | An algorithm for traversing or searching tree or graph data structures, starting from the root node and exploring neighbors at the present depth level before moving on to nodes at the next depth level. |
| **Depth-First Search (DFS)** | An algorithm for traversing or searching tree or graph data structures by exploring as far as possible along each branch before backtracking. |
| **Binary Search**          | A search algorithm that finds the position of a target value within a sorted array by repeatedly dividing the search interval in half. |
| **Hashing**                | The process of converting an input (or 'key') into a fixed-size string of bytes, typically for fast data retrieval in a hash table. |
| **Big-O Notation**         | A mathematical notation that describes the upper bound of the time complexity of an algorithm, providing a worst-case scenario of its performance as the input size grows. |
| **Time Complexity**        | A computational complexity that describes the amount of time it takes to run an algorithm as a function of the length of the input. |
| **Space Complexity**       | A computational complexity that describes the amount of memory space required by an algorithm as a function of the length of the input. |
| **Kruskal's Algorithm**    | An algorithm for finding the minimum spanning tree in a weighted graph, where the edges are added to the tree in increasing order of weight. |
| **Prim's Algorithm**       | An algorithm for finding the minimum spanning tree in a weighted graph, starting from an arbitrary node and growing the tree one vertex at a time. |
| **Dijkstra's Algorithm**   | An algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. |
| **Bellman-Ford Algorithm** | An algorithm for finding the shortest paths from a single source vertex to all other vertices in a weighted graph, allowing for negative weight edges. |
| **Floyd-Warshall Algorithm** | A dynamic programming algorithm for finding the shortest paths in a weighted graph with positive or negative edge weights between all pairs of vertices. |
| **Topological Sorting**    | A linear ordering of vertices in a directed graph where for every directed edge UV from vertex U to vertex V, U comes before V in the ordering. |
| **Knapsack Problem**       | A problem in combinatorial optimization where the goal is to select a subset of items with given weights and values to maximize the total value without exceeding a weight limit. |
| **Travelling Salesman Problem (TSP)** | A classic algorithmic problem in the field of operations research and optimization where the objective is to find the shortest possible route that visits each city exactly once and returns to the origin city. |
